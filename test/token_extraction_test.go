package test

import (
	"github.com/byxor/qbd/tokens"
	"github.com/stretchr/testify/assert"
	"testing"
	"time"
)

func TestChannelIsClosedWhenThereAreNoBytes(t *testing.T) {
	tokenChannel := make(chan tokens.Token)
	go tokens.Extract(tokenChannel, []byte{})
	assertThereIsNothingLeft(t, tokenChannel)
}

func TestChannelIsClosedWhenFinished(t *testing.T) {
	tokenChannel := make(chan tokens.Token)
	bytes := []byte{0x00, 0x00, 0x00}

	go tokens.Extract(tokenChannel, bytes)

	for i := 0; i <= len(bytes); i++ {
		expectingMore := i < len(bytes)
		_, more := readOneFrom(tokenChannel)
		assert.Equal(t, expectingMore, more)
	}
}

func TestChannelIsClosedUponReceivingInvalidToken(t *testing.T) {
	tokenChannel := make(chan tokens.Token)
	bytes := []byte{0x16, 0x00}
	go tokens.Extract(tokenChannel, bytes)
	readOneFrom(tokenChannel)
	_, more := readOneFrom(tokenChannel)
	assert.False(t, more)
}

func TestExtractingTokens(t *testing.T) {
	entries := []struct {
		bytes    []byte
		expected tokens.Token
	}{
		{[]byte{0x00}, tokens.EndOfFile},
		{[]byte{0x01}, tokens.EndOfLine},
		{[]byte{0x03}, tokens.StartOfStruct},
		{[]byte{0x04}, tokens.EndOfStruct},
		{[]byte{0x05}, tokens.StartOfArray},
		{[]byte{0x06}, tokens.EndOfArray},

		{[]byte{0x07}, tokens.Assignment},

		{[]byte{0x09}, tokens.Comma},

		{[]byte{0x0A}, tokens.Subtraction},
		{[]byte{0x0B}, tokens.Addition},
		{[]byte{0x0C}, tokens.Division},
		{[]byte{0x0D}, tokens.Multiplication},

		{[]byte{0x0E}, tokens.StartOfExpression},
		{[]byte{0x0F}, tokens.EndOfExpression},

		{[]byte{0x11}, tokens.EqualityCheck},
		{[]byte{0x12}, tokens.LessThanCheck},
		{[]byte{0x13}, tokens.LessThanOrEqualCheck},
		{[]byte{0x14}, tokens.GreaterThanCheck},
		{[]byte{0x15}, tokens.GreaterThanOrEqualCheck},

		{[]byte{0x16, 0x00, 0x00, 0x00, 0x00}, tokens.Name},
		{[]byte{0x16, 0xBB, 0xEE, 0xEE, 0xFF}, tokens.Name},
		// Invalid names (not enough bytes)
		{[]byte{0x16, 0x00, 0x00, 0x00}, tokens.Invalid},
		{[]byte{0x16, 0x11, 0x22}, tokens.Invalid},
		{[]byte{0x16, 0x33}, tokens.Invalid},
		{[]byte{0x16}, tokens.Invalid},

		{[]byte{0x17, 0x00, 0x00, 0x00, 0x00}, tokens.Integer},
		{[]byte{0x17, 0xBA, 0x5E, 0xBA, 0x11}, tokens.Integer},
		// Invalid integers (not enough bytes)
		{[]byte{0x17, 0x00, 0x00, 0x00}, tokens.Invalid},
		{[]byte{0x17, 0x11, 0x22}, tokens.Invalid},
		{[]byte{0x17, 0x33}, tokens.Invalid},
		{[]byte{0x17}, tokens.Invalid},

		{[]byte{0x1A, 0x00, 0x00, 0x00, 0x00}, tokens.Float},
		{[]byte{0x1A, 0x12, 0x34, 0x56, 0x78}, tokens.Float},
		// Invalid floats (not enough bytes)
		{[]byte{0x1A, 0x00, 0x00, 0x00}, tokens.Invalid},
		{[]byte{0x1A, 0x11, 0x22}, tokens.Invalid},
		{[]byte{0x1A, 0x33}, tokens.Invalid},
		{[]byte{0x1A}, tokens.Invalid},

		{[]byte{0x1B, 0x00, 0x00, 0x00, 0x00}, tokens.String},
		{[]byte{0x1B, 0x01, 0x00, 0x00, 0x00, 0xFF}, tokens.String},
		{[]byte{0x1B, 0x02, 0x00, 0x00, 0x00, 0xF0, 0x0D}, tokens.String},
		// Invalid strings (not enough bytes for string length)
		{[]byte{0x1B, 0x00, 0x00, 0x00}, tokens.Invalid},
		{[]byte{0x1B, 0x00, 0x00}, tokens.Invalid},
		{[]byte{0x1B, 0x00}, tokens.Invalid},
		{[]byte{0x1B}, tokens.Invalid},
		// Invalid strings (not enough bytes in string)
		{[]byte{0x1B, 0x01, 0x00, 0x00, 0x00}, tokens.Invalid},
		{[]byte{0x1B, 0x05, 0x00, 0x00, 0x00, 0xEE, 0xEE, 0xEE, 0xEE}, tokens.Invalid},

		{[]byte{0x1C, 0x00, 0x00, 0x00, 0x00}, tokens.LocalString},
		{[]byte{0x1C, 0x01, 0x00, 0x00, 0x00, 0xFF}, tokens.LocalString},
		{[]byte{0x1C, 0x02, 0x00, 0x00, 0x00, 0xF0, 0x0D}, tokens.LocalString},
		// Invalid local strings (not enough bytes for string length)
		{[]byte{0x1C, 0x00, 0x00, 0x00}, tokens.Invalid},
		{[]byte{0x1C, 0x00, 0x00}, tokens.Invalid},
		{[]byte{0x1C, 0x00}, tokens.Invalid},
		{[]byte{0x1C}, tokens.Invalid},
		// Invalid local strings (not enough bytes in string)
		{[]byte{0x1C, 0x01, 0x00, 0x00, 0x00}, tokens.Invalid},
		{[]byte{0x1C, 0x05, 0x00, 0x00, 0x00, 0xEE, 0xEE, 0xEE, 0xEE}, tokens.Invalid},

		{[]byte{0x1F, 0x00, 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x11}, tokens.Pair},
		{[]byte{0x1F, 0x12, 0x34, 0x56, 0x78, 0xfe, 0xdc, 0xba, 0x98}, tokens.Pair},
		{[]byte{0x1F, 0x12, 0x34, 0x56, 0x78, 0xfe, 0xdc, 0xba, 0x98}, tokens.Pair},
		// Invalid pairs (not enough bytes)
		{[]byte{0x1F, 0x12, 0x34, 0x56, 0x78, 0xfe, 0xdc, 0xba}, tokens.Invalid},
		{[]byte{0x1F, 0x12, 0x34, 0x56, 0x78, 0xfe, 0xdc}, tokens.Invalid},
		{[]byte{0x1F, 0x12, 0x34, 0x56, 0x78, 0xfe}, tokens.Invalid},
		{[]byte{0x1F, 0x12, 0x34, 0x56, 0x78}, tokens.Invalid},
		{[]byte{0x1F, 0x12, 0x34, 0x56}, tokens.Invalid},
		{[]byte{0x1F, 0x12, 0x34}, tokens.Invalid},
		{[]byte{0x1F, 0x12}, tokens.Invalid},
		{[]byte{0x1F}, tokens.Invalid},

		{[]byte{0x20}, tokens.While},
		{[]byte{0x21}, tokens.Repeat},

		{[]byte{0x23}, tokens.StartOfFunction},
		{[]byte{0x24}, tokens.EndOfFunction},
		{[]byte{0x29}, tokens.Return},

		{[]byte{0x22}, tokens.Break},

		{[]byte{0x25}, tokens.StartOfIf},
		{[]byte{0x26}, tokens.Else},
		{[]byte{0x27}, tokens.ElseIf},
		{[]byte{0x28}, tokens.EndOfIf},

		{[]byte{0x2B, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00}, tokens.ChecksumTableEntry},
		{[]byte{0x2B, 0x11, 0x22, 0x33, 0x44, 0x43, 0x6F, 0x63, 0x6B, 0x00}, tokens.ChecksumTableEntry},
		// Invalid checksum table entries (not enough bytes)
		{[]byte{0x2B, 0x00, 0x00, 0x00, 0x00, 0x00}, tokens.Invalid},
		{[]byte{0x2B, 0xAB, 0xCD, 0xEF, 0x00}, tokens.Invalid},
		{[]byte{0x2B, 0x12, 0x34, 0x56}, tokens.Invalid},
		{[]byte{0x2B, 0xFF, 0xDE}, tokens.Invalid},
		{[]byte{0x2B, 0xE2}, tokens.Invalid},
		{[]byte{0x2B}, tokens.Invalid},
		// Invalid checksum table entries (not null-terminated)
		{[]byte{0x2B, 0x11, 0x22, 0x33, 0x44, 0x43, 0x6F, 0x63, 0x6B}, tokens.Invalid},
		{[]byte{0x2B, 0x00, 0xAA, 0xEE, 0xFF, 0x01, 0x02, 0x03}, tokens.Invalid},

		{[]byte{0x2C}, tokens.AllLocalReferences},
		{[]byte{0x2D}, tokens.LocalReference},

		{[]byte{0x2E, 0x00, 0x00, 0x00, 0x00}, tokens.LongJump},
		{[]byte{0x2E, 0xF3, 0x3D, 0xB0, 0x0B}, tokens.LongJump},
		// Invalid longjump (not enough bytes)
		{[]byte{0x2E, 0x11, 0x22, 0x33}, tokens.Invalid},
		{[]byte{0x2E, 0x11, 0x22}, tokens.Invalid},
		{[]byte{0x2E, 0x11}, tokens.Invalid},
		{[]byte{0x2E}, tokens.Invalid},

		// ExecuteRandomBlock (very complicated)
		{[]byte{
			0x2F,
			0x02, 0x00, 0x00, 0x00, // number of code blocks
			0x01, 0x00, // weight of 1st code block
			0x01, 0x00, // weight of 2nd code block
			0x04, 0x00, 0x00, 0x00, // offset to 1st code block
			0x10, 0x00, 0x00, 0x00, // offset to 2nd code block

			0x16, 0xFF, 0xFF, 0xFF, 0xFF, // 1st code block
			0x07,                         // ...
			0x17, 0x01, 0x00, 0x00, 0x00, // ...
			0x2E, 0x0B, 0x00, 0x00, 0x00, // jump to end

			0x16, 0xFF, 0xFF, 0xFF, 0xFF, // 2nd code block
			0x07,                         // ...
			0x17, 0x01, 0x00, 0x00, 0x00, // ...
			// no jump (already at the end)
		}, tokens.ExecuteRandomBlock},

		{[]byte{
			0x2F,
			0x03, 0x00, 0x00, 0x00, // number of code blocks
			0x01, 0x00, // weight of 1st code block
			0x01, 0x00, // weight of 2nd code block
			0x01, 0x00, // weight of 3rd code block
			0x08, 0x00, 0x00, 0x00, // offset to 1st code block
			0x14, 0x00, 0x00, 0x00, // offset to 2nd code block
			0x20, 0x00, 0x00, 0x00,

			0x16, 0xFF, 0xFF, 0xFF, 0xFF, // 1st code block
			0x07,
			0x17, 0x01, 0x00, 0x00, 0x00,
			0x2E, 0x1B, 0x00, 0x00, 0x00, // jump to end

			0x16, 0xFF, 0xFF, 0xFF, 0xFF, // 2nd code block
			0x07,
			0x17, 0x01, 0x00, 0x00, 0x00,
			0x2E, 0x0B, 0x00, 0x00, 0x00, // jump to end

			0x16, 0xFF, 0xFF, 0xFF, 0xFF, // 3rd code block
			0x07,
			0x17, 0x01, 0x00, 0x00, 0x00,
			// no jump (already at end)
		}, tokens.ExecuteRandomBlock},

		// Invalid ExecuteRandomBlock (not enough weights)
		{[]byte{
			0x2F,
			0x03, 0x00, 0x00, 0x00,
			0x01, 0x00,
			0x01, 0x00,
			0x08, 0x00, 0x00, 0x00,
			0x14, 0x00, 0x00, 0x00,
			0x20, 0x00, 0x00, 0x00,

			0x16, 0xFF, 0xFF, 0xFF, 0xFF,
			0x07,
			0x17, 0x01, 0x00, 0x00, 0x00,
			0x2E, 0x1B, 0x00, 0x00, 0x00,

			0x16, 0xFF, 0xFF, 0xFF, 0xFF,
			0x07,
			0x17, 0x01, 0x00, 0x00, 0x00,
			0x2E, 0x0B, 0x00, 0x00, 0x00,

			0x16, 0xFF, 0xFF, 0xFF, 0xFF,
			0x07,
			0x17, 0x01, 0x00, 0x00, 0x00,
		}, tokens.Invalid},

		// Invalid ExecuteRandomBlock (bad offsets)
		{[]byte{
			0x2F,
			0x03, 0x00, 0x00, 0x00,
			0x01, 0x00,
			0x01, 0x00,
			0x01, 0x00,
			0x08, 0x00, 0x00, 0x00,
			0xFF, 0x00, 0x00, 0x00,
			0xFF, 0x00, 0x00, 0x00,
			0xFF, 0x00, 0x00, 0x00,

			0x16, 0xFF, 0xFF, 0xFF, 0xFF,
			0x07,
			0x17, 0x01, 0x00, 0x00, 0x00,
			0x2E, 0x1B, 0x00, 0x00, 0x00,

			0x16, 0xFF, 0xFF, 0xFF, 0xFF,
			0x07,
			0x17, 0x01, 0x00, 0x00, 0x00,
			0x2E, 0x0B, 0x00, 0x00, 0x00,

			0x16, 0xFF, 0xFF, 0xFF, 0xFF,
			0x07,
			0x17, 0x01, 0x00, 0x00, 0x00,
		}, tokens.Invalid},

		// Invalid ExecuteRandomBlock (no longjumps)
		{[]byte{
			0x2F,
			0x03, 0x00, 0x00, 0x00,
			0x01, 0x00,
			0x01, 0x00,
			0x01, 0x00,
			0x08, 0x00, 0x00, 0x00,
			0xFF, 0x00, 0x00, 0x00,
			0xFF, 0x00, 0x00, 0x00,
			0xFF, 0x00, 0x00, 0x00,

			0x16, 0xFF, 0xFF, 0xFF, 0xFF,
			0x07,
			0x17, 0x01, 0x00, 0x00, 0x00,

			0x16, 0xFF, 0xFF, 0xFF, 0xFF,
			0x07,
			0x17, 0x01, 0x00, 0x00, 0x00,

			0x16, 0xFF, 0xFF, 0xFF, 0xFF,
			0x07,
			0x17, 0x01, 0x00, 0x00, 0x00,
		}, tokens.Invalid},

		{[]byte{0x33}, tokens.And},
		{[]byte{0x39}, tokens.Not},

		{[]byte{0x3C}, tokens.StartOfSwitch},
		{[]byte{0x3D}, tokens.EndOfSwitch},
		{[]byte{0x3E}, tokens.SwitchCase},
		{[]byte{0x3F}, tokens.DefaultSwitchCase},

		{[]byte{0x42}, tokens.NamespaceAccess},

		{[]byte{0x47, 0x00, 0x00}, tokens.OptimisedIf},
		{[]byte{0x47, 0xDE, 0xAD}, tokens.OptimisedIf},
		// Invalid optimised if (not enough bytes)
		{[]byte{0x47, 0x11}, tokens.Invalid},
		{[]byte{0x47}, tokens.Invalid},

		{[]byte{0x48, 0x00, 0x00}, tokens.OptimisedElse},
		{[]byte{0x48, 0xDE, 0xAD}, tokens.OptimisedElse},
		// Invalid optimised else (not enough bytes)
		{[]byte{0x48, 0xFE}, tokens.Invalid},
		{[]byte{0x48}, tokens.Invalid},

		{[]byte{0x49, 0x00, 0x00}, tokens.ShortJump},
		{[]byte{0x49, 0xBE, 0xEF}, tokens.ShortJump},
		// Invalid shortjump (not enough bytes)
		{[]byte{0x49, 0x00}, tokens.Invalid},
		{[]byte{0x49}, tokens.Invalid},
	}

	for _, entry := range entries {
		tokenChannel := make(chan tokens.Token)
		go tokens.Extract(tokenChannel, entry.bytes)
		token, _ := readOneFrom(tokenChannel)
		assert.Equal(t, entry.expected.String(), token.String())
		assertThereIsNothingLeft(t, tokenChannel)
	}
}

func TestExtractingMultipleTokens(t *testing.T) {
	entries := []struct {
		bytes  []byte
		output []tokens.Token
	}{
		{[]byte{0x01, 0x01}, []tokens.Token{tokens.EndOfLine, tokens.EndOfLine}},
		{[]byte{0x01, 0x00}, []tokens.Token{tokens.EndOfLine, tokens.EndOfFile}},

		{[]byte{0x01, 0x01, 0x01},
			[]tokens.Token{tokens.EndOfLine, tokens.EndOfLine, tokens.EndOfLine}},

		{[]byte{
			0x17, 0x00, 0x00, 0x00, 0x00,
			0x17, 0x01, 0x00, 0x00, 0x00,
		}, []tokens.Token{tokens.Integer, tokens.Integer}},

		{[]byte{
			0x16, 0xFF, 0x00, 0x00, 0xDD,
			0x2B, 0x11, 0x11, 0x11, 0x11, 0x68, 0x69, 0x00,
		}, []tokens.Token{tokens.Name, tokens.ChecksumTableEntry}},

		{[]byte{
			0x01,
			0x23,
			0x16, 0x93, 0x4D, 0xCD, 0xA1,
		}, []tokens.Token{tokens.EndOfLine, tokens.StartOfFunction, tokens.Name}},
	}

	for _, entry := range entries {
		tokenChannel := make(chan tokens.Token)
		go tokens.Extract(tokenChannel, entry.bytes)

		for _, expected := range entry.output {
			token, _ := readOneFrom(tokenChannel)
			assert.Equal(t, expected.String(), token.String())
		}
	}
}

func readOneFrom(tokens chan tokens.Token) (token tokens.Token, more bool) {
	select {
	case token, more = <-tokens:
		return
	case <-time.After(3 * time.Second):
		panic("Timed out while reading tokens...")
	}
}

func assertThereIsNothingLeft(t *testing.T, tokenChannel chan tokens.Token) {
	_, more := readOneFrom(tokenChannel)
	assert.False(t, more)
}
